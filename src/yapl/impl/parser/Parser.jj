/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(Parser)
package yapl.impl.parser;
import java.io.*;

import yapl.impl.BackendMJ;
import yapl.impl.compiler.CodeGenAsMJ;
import yapl.impl.symbolcheck.SymbolImpl;
import yapl.impl.symbolcheck.SymboltableImpl;
import yapl.interfaces.BackendBinSM;
import yapl.interfaces.CodeGen;
import yapl.lib.*;



public class Parser
{
  public static String programName;
  public static SymboltableImpl table = new SymboltableImpl();

  public static void main(String args []) throws ParseException, FileNotFoundException, TokenMgrError, YAPLException
  {
    try
    {
      Parser parser = new Parser(new FileInputStream(args [0]));
      BackendBinSM backend = new BackendMJ();
      CodeGen codegen = new CodeGenAsMJ(backend);
      parser.Program();
      CompilerMessage.printOK(Parser.programName);
    }
    catch (TokenMgrError e)
    {
      CompilerMessage.printError(e, Parser.programName);
    }
    catch (ParseException e)
    {
      CompilerMessage.printError(e, Parser.programName);
    }
    catch (YAPLException e)
    {
	  CompilerMessage.printError(e, Parser.programName);
	  e.printStackTrace();
   	} 
  }

  public static SymbolImpl lookup(int errorNumber, SymbolImpl sym, Token t) throws YAPLException {
    SymbolImpl s = (SymbolImpl) table.lookup(t.toString());
    if(s == null) {
		throw new YAPLException(11, null, t);
  	}
  	return s;
  }

  public static void isValidIntOp(Token t, Type type1, Type type2, int errorNumber) throws YAPLException {
	if(!(type1 instanceof IntType) || !(type2 instanceof IntType)) {
      throw new YAPLException(errorNumber, null, t);
    }
  }
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN :
{
  //---KEYWORDS---
  < PROGRAM : "Program" >
| < TRUTHVALUE :
    "True"
  | "False" >
| < ANDOP : "And" >
| < OROP : "Or" >
| < NEWOP : "new" >
| < IF : "If" >
| < THEN : "Then" >
| < ELSE : "Else" >
| < ENDIF : "EndIf" >
| < WHILE : "While" >
| < DO : "Do" >
| < ENDWHILE : "EndWhile" >
| < RETURN : "Return" >
| < WRITE : "Write" >
| < BEGIN : "Begin" >
| < END : "End" >
| < INT : "int" >
| < BOOL : "bool" >
| < CONSTANT : "Const" >
| < RECORD : "Record" >
| < ENDRECORD : "EndRecord" >
| < DECLARE : "Declare" >
| < PROCEDURE : "Procedure" >
| < VOID : "void" >
| < DELIMITER : ";" >
  //---TOKENS---
| < openingParenthesis : "(" >
| < closingParenthesis : ")" >
| < openingBrackets : "[" >
| < closingBrackets : "]" >
| < hash : "#" >
| < dot : "." >
| < colon : "," >
| < assignOp : ":=" >
| < constAssignOp : "=" >
| < less : "<" >
| < lessequal : "<=" >
| < greater : ">" >
| < greaterequal : ">=" >
| < plus : "+" >
| < minus : "-" >
| < multiply : "*" >
| < divide : "/" >
| < modulo : "%" >
| < equals : "==" >
| < nequals : "!=" >
| < ident :
    < letter >
    (
      < letter >
    | < digit >
    )* >
| < number : < digit > (< digit >)* >
| < letter :
    [ "A"-"Z" ]
  | [ "a"-"z" ]
  | "_" >
| < digit : [ "0"-"9" ] >
| < otherchar :
    "+"
  | "-"
  | "*"
  | "/"
  | "."
  | ","
  | ";"
  | ":"
  | "!"
  | 
    "?"
  | "="
  | "#"
  | "%"
  | "<"
  | ">"
  | "$"
  | "("
  | ")"
  | 
    "["
  | "]"
  | "{"
  | "}"
  | "\\"
  | "@"
  | "&"
  | "^"
  | "|" >
| < string :
    "\""
    (
      " "
    | < letter >
    | < digit >
    | < otherchar >
    )*
    "\"" >
}

SPECIAL_TOKEN :
{
  < comment: "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">
}

Type Literal() :
{}
{
  < TRUTHVALUE > { return new BoolType(); }
| < number > { return new IntType(); }
}

TypeAndToken Selector(Type input) throws YAPLException :
{
  Type type;
  Token t;
  TypeAndToken tt = new TypeAndToken();
}
{
  (
    < openingBrackets > type = Expr()
    t = < closingBrackets >
    {
	  if(!(type instanceof IntType)) {
		throw new YAPLException(21, null, t);
	  } 
	}
  | < dot > t = < ident >
  )
  {
    tt.setToken(t);	
    if(input instanceof ArrayType) { 
		tt.setType(((ArrayType)input).getSubarray());	
	}
  }
  (
    tt = Selector(tt.getType())
  )?
  {
    return tt;
  }
}

Type ArrayLen() throws YAPLException :
{
	Token t;
}
{
  < hash > t = < ident >
  {
    SymbolImpl sym = lookup(11, null, t);
    if(sym.getKind() != 2 && sym.getKind() != 6) {
		throw new YAPLException(12, sym, t);
	}
	if(!(sym.getType() instanceof ArrayType) || ((ArrayType)sym.getType()).getDim() < 1) {
		throw new YAPLException(22, null, t);
	}
	return new IntType();
  }
  (
    Selector(sym.getType())
  )?
}

Type PrimaryExpr() throws YAPLException :
{
	Token t = null;
	Type type;
	TypeAndToken tt = null;
}
{
  type = Literal() { return type; }
| < openingParenthesis > type = Expr() < closingParenthesis > { return type; }
|
  (
    LOOKAHEAD( t = < ident >, { getToken(2).kind == openingParenthesis })
    type = ProcedureCall(true)
    {
      return type;
    }
  | t = < ident >
  {
    SymbolImpl sym = lookup(11, null, t);
    if(sym.getKind() != 2 && sym.getKind() != 3 && sym.getKind() != 6) {
		throw new YAPLException(12, sym, t);
  	}
  	type = sym.getType();
  }
    (
      tt = Selector(type)
      {
		  if(!(sym.getType() instanceof ArrayType) || ((ArrayType)sym.getType()).getDim() <  1) {
		    if(!(sym.getType() instanceof RecordType)) { 
				throw new YAPLException(20, null, tt.getToken());
			}
 		  }
 		  //type = ((ArrayType)type).getSubarray();
      }
    )?
    {
		return tt != null ? tt.getType() : type;
    }
  )
| type = ArrayLen() { return type; }
}

Type UnaryExpr() throws YAPLException :
{
  	Token t = null;
	Type type;
}
{
  (
    t = AddOp()
  )?
  type = PrimaryExpr()
  {
    if(t != null && !(type instanceof IntType)) {
		throw new YAPLException(23, null, t);
    } 
    return type;
  }
}

Type MulExpr() throws YAPLException :
{
  	Token t;
	Type type1;
	Type type2;
}
{
  type1 =  UnaryExpr()
  (
    t = MulOp() type2 = UnaryExpr()
    {
      isValidIntOp(t, type1, type2, 24);
    }
  )*
  {
    return type1;
  }  
}

Type AddExpr() throws YAPLException :
{
  	Token t;
	Type type1;
	Type type2;
}
{
  type1 = MulExpr()
  (
    t = AddOp() type2 = MulExpr()
    {
      isValidIntOp(t, type1, type2, 24);
    }
  )*
  {
    return type1;
  } 
}

Type RelExpr() throws YAPLException :
{
	Token t;
	Type type1;
	Type type2;
}
{
  type1 = AddExpr()
  (
    t = RelOp() type2 = AddExpr()
    {
      isValidIntOp(t, type1, type2, 25);
      return new BoolType();
    }
  )?
  {
    return type1;
  } 
}

Type EqualExpr() throws YAPLException :
{
	Token t;
	Type type1;
	Type type2;
}
{
  type1 = RelExpr()
  (
    t = EqualOp() type2 = RelExpr()
    {
	    if(!(type1.getClass().equals(type2.getClass()))) {
			throw new YAPLException(26, null, t);
	  	}
	  	return new BoolType();
    }
  )?
  {
  	return type1;  
  }
}

Type CondAndExpr() throws YAPLException :
{
	Token t;
	Type type1;
	Type type2;
}
{
  type1 = EqualExpr()
  (
    t = < ANDOP > type2 = EqualExpr()
    { 
	    if(!(type1 instanceof BoolType) || !(type2 instanceof BoolType)) {
			throw new YAPLException(24, null, t);
	  	}
    }  	
  )*
  {
    return type1;
  }
}

Type CreationExpr()  throws YAPLException :
{
  Type type;
  ArrayType arr;
  Token t;
}
{
  < NEWOP > type = NonArrayType()
  {
    arr = new ArrayType(0, type);
  }
  (
    t = < openingBrackets > type = Expr() < closingBrackets >
    {
      	if(!(type instanceof IntType)) {
			throw new YAPLException(21, null, t);
        }  
		arr.incDim();
    }
  )*
  {
    return arr;
  }
}

Type Expr() throws YAPLException :
{
	Token t;
	Type type1;
	Type type2;
}
{
  type1 = CondAndExpr()
  (
    t = < OROP > type2 = CondAndExpr()
    {
		if(!(type1 instanceof BoolType) || !(type2 instanceof BoolType)) {
			throw new YAPLException(24, null, t);
  		}
    }
  )*
  {
  	return type1;
  }
| type1 = CreationExpr()
{
  return type1;
}

}

void ArgumentList() throws YAPLException :
{}
{
  Expr()
  (
    < colon > Expr()
  )*
}

Type ProcedureCall(boolean checkVoid) throws YAPLException :
{
	Token t;
}
{
  t = < ident > < openingParenthesis >
  {
	SymbolImpl sym = lookup(11, null, t);
	if(sym.getKind() != 1) {
		throw new YAPLException(12, sym, t);
	}
	if(checkVoid) {
	  if(sym.getType() instanceof VoidType) {
		throw new YAPLException(27, null, t);
      }  
	}
  }  
  (
    ArgumentList()
  )?
  < closingParenthesis >
  {
    return sym.getType();  
  }
}

void Assignment() throws YAPLException:
{
  Token t;
  Type type;
  Boolean selector = false;
}
{
  t = < ident >
  {
    SymbolImpl sym = lookup(11, null, t);
    if(sym.getKind() != 2 && sym.getKind() != 6) {
		throw new YAPLException(12, sym, t);
	}
  }
  (
    Selector(sym.getType())
    { selector = true; }
  )?
  t = < assignOp > type = Expr()
  {
    if(!selector && !(sym.getType().getClass().equals(type.getClass()))) {
		throw new YAPLException(29, null, t);
  	}
  	if(selector && !(((ArrayType)sym.getType()).getElem().getClass().equals(type.getClass()))) {
		throw new YAPLException(29, null, t);
 	}   
  } 
}

void IfStatement() throws YAPLException :
{}
{
  < IF > Expr() < THEN > StatementList()
  (
    < ELSE > StatementList()
  )?
  < ENDIF >
}

void WhileStatement() throws YAPLException :
{}
{
  < WHILE > Expr() < DO > StatementList() < ENDWHILE >
}

void ReturnStatement() throws YAPLException :
{}
{
  < RETURN >
  (
    Expr()
  )?
}

void WriteStatement() :
{}
{
  < WRITE > < string >
}

void Statement() throws YAPLException :
{
}
{
  IfStatement()
| WhileStatement()
| ReturnStatement()
| WriteStatement()
|
  (
    LOOKAHEAD(< ident >, { getToken(2).kind != openingParenthesis })
    Assignment()
  | ProcedureCall(false)
  )
| Block()
}

void StatementList() throws YAPLException :
{}
{
  (
    Statement() < DELIMITER >
  )*
}

void Block() throws YAPLException :
{}
{
  {
	table.openScope(false);
  }
  (
    Decl()
  )?
  < BEGIN >
  StatementList() < END >
  {
    table.closeScope();
  }
}

Type NonArrayType() throws YAPLException :
{
	Token t;
}
{
  < INT > { return new IntType(); }
| < BOOL > { return new BoolType(); }
| t = < ident > 
{
  SymbolImpl sym = lookup(11, null, t);
  if(sym.getKind() != 4) {
	throw new YAPLException(12, sym, t);
  }
  return sym.getType();
}
}

Type Type() throws YAPLException :
{
	Type type;
	ArrayType temp;
}
{
  type = NonArrayType()
  { temp = new ArrayType(0, type); }
  (< openingBrackets > < closingBrackets > { temp.incDim(); })*
  {
	return temp.getDim() > 0 ? temp : type;
  }
}

Type ReturnType() throws YAPLException :
{
	Type type;
}
{
  < VOID > { return new VoidType(); }
| type = Type() { return type; }
}

void ConstDecl() throws YAPLException :
{
	Token t;
	Type type;
}
{
  < CONSTANT > t = < ident > < constAssignOp >  type = Literal() < DELIMITER >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(3);
    sym.setType(type);
    table.addSymbol(sym, t);
  }
}

void VarDecl()  throws YAPLException:
{
	Token t;
	Token t2;
	Type type;
}
{
  {
	t2 = null;
  } 
  type = Type() t = < ident >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(2);
    sym.setType(type);
    table.addSymbol(sym, t);
  }
  ("," t2 = < ident >
	{
    	if(t2 != null) {
	      	SymbolImpl sym2 = new SymbolImpl();
	    	sym2.setName(t2.toString());
	    	sym2.setKind(2);
	    	sym2.setType(type);
	    	table.addSymbol(sym2, t2);
	    }	
  	}
  )* < DELIMITER >
   	
  
}

void TypeDecl()  throws YAPLException:
{
	Token t;
}
{
  {
    table.openScope(true);
  }
  < RECORD > t = < ident > VarDecl()
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(4);
    sym.setType(new RecordType());
    table.addSymbol(sym, t);
  }
  (
    VarDecl()
  )*
  < ENDRECORD > < DELIMITER >
  {
    table.closeScope();
  }
}

void Decl()  throws YAPLException:
{}
{
  < DECLARE >
  (
    ConstDecl()
  | VarDecl()
  | TypeDecl()
  )*
}

void FormalParam() throws YAPLException :
{
	Token t;
	Type type;
}
{
  type = Type() t = < ident >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(6);
    sym.setType(type);
    table.addSymbol(sym, t);
  }
}

void FormalParamList()  throws YAPLException :
{}
{
  FormalParam()
  (
    < colon > FormalParam()
  )*
}

void Procedure() throws YAPLException :
{
	Token t;
	Type type;
}
{
  < PROCEDURE > type = ReturnType() t = < ident > < openingParenthesis >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(1);
    sym.setType(type);
    sym.setGlobal(true);
    table.openScope(true);
    table.setParentSymbol(sym, t);
  }
  (
    FormalParamList()
  )?
  < closingParenthesis > Block() t = < ident > < DELIMITER >
  {
	if(!table.getNearestParentSymbol(1).getName().equals(t.toString())) {
		throw new YAPLException(13, sym, t);
	}
    table.closeScope();
  }
}

void Program() throws YAPLException:
{
  Token t;
}
{
  < PROGRAM > t = < ident >
  {
    Parser.programName = t.toString();
    
    table.openScope(true);
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(0);
    table.setParentSymbol(sym, t);
  }
  (
    Decl()
  | Procedure()
  )*
  < BEGIN > StatementList() < END > t = < ident > < dot >
  {
	if(!table.getNearestParentSymbol(0).getName().equals(t.toString())) {
		throw new YAPLException(13, sym, t);
	}
	table.closeScope();
  }
}

Token RelOp() :
{
	Token t;
}
{
  t = < less > { return t; }
| t = < lessequal > { return t; }
| t = < greaterequal > { return t; }
| t = < greater > { return t; }
}

Token EqualOp() :
{
  Token t;
}
{
  t = < equals > { return t; }
| t = < nequals > { return t; }
}

Token AddOp() :
{
	Token t;
}
{
  t = < plus > { return t; }
| t = < minus > { return t; }
}

Token MulOp() :
{
	Token t;
}
{
  t = < multiply > { return t; }
| t = < divide > { return t; }
| t = < modulo > { return t; }
}
