/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(Parser)
package yapl.impl.parser;
import java.io.*;
import yapl.lib.CompilerMessage;
import yapl.impl.symbolcheck.SymboltableImpl;
import yapl.impl.symbolcheck.SymbolImpl;
import yapl.lib.YAPLException;

public class Parser
{
  public static String programName;
  public static SymboltableImpl table = new SymboltableImpl();

  public static void main(String args []) throws ParseException, FileNotFoundException, TokenMgrError, YAPLException
  {
    try
    {
      Parser parser = new Parser(new FileInputStream(args [0]));
      parser.Program();
      CompilerMessage.printOK(Parser.programName);
    }
    catch (TokenMgrError e)
    {
      CompilerMessage.printError(e, Parser.programName);
    }
    catch (ParseException e)
    {
      CompilerMessage.printError(e, Parser.programName);
    }
    catch (YAPLException e)
    {
	  CompilerMessage.printError(e, Parser.programName);	
   	} 
  }

  public static SymbolImpl lookup(int errorNumber, SymbolImpl sym, Token t) throws YAPLException {
    SymbolImpl s = (SymbolImpl) table.lookup(t.toString());
    if(s == null) {
		throw new YAPLException(11, null, t);
  	}
  	return s;
  }  
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN :
{
  //---KEYWORDS---
  < PROGRAM : "Program" >
| < TRUTHVALUE :
    "True"
  | "False" >
| < ANDOP : "And" >
| < OROP : "Or" >
| < NEWOP : "new" >
| < IF : "If" >
| < THEN : "Then" >
| < ELSE : "Else" >
| < ENDIF : "EndIf" >
| < WHILE : "While" >
| < DO : "Do" >
| < ENDWHILE : "EndWhile" >
| < RETURN : "Return" >
| < WRITE : "Write" >
| < BEGIN : "Begin" >
| < END : "End" >
| < INT : "int" >
| < BOOL : "bool" >
| < CONSTANT : "Const" >
| < RECORD : "Record" >
| < ENDRECORD : "EndRecord" >
| < DECLARE : "Declare" >
| < PROCEDURE : "Procedure" >
| < VOID : "void" >
| < DELIMITER : ";" >
  //---TOKENS---
| < openingParenthesis : "(" >
| < closingParenthesis : ")" >
| < openingBrackets : "[" >
| < closingBrackets : "]" >
| < hash : "#" >
| < dot : "." >
| < colon : "," >
| < assignOp : ":=" >
| < constAssignOp : "=" >
| < less : "<" >
| < lessequal : "<=" >
| < greater : ">" >
| < greaterequal : ">=" >
| < plus : "+" >
| < minus : "-" >
| < multiply : "*" >
| < divide : "/" >
| < modulo : "%" >
| < equals : "==" >
| < nequals : "!=" >
| < ident :
    < letter >
    (
      < letter >
    | < digit >
    )* >
| < number : < digit > (< digit >)* >
| < letter :
    [ "A"-"Z" ]
  | [ "a"-"z" ]
  | "_" >
| < digit : [ "0"-"9" ] >
| < otherchar :
    "+"
  | "-"
  | "*"
  | "/"
  | "."
  | ","
  | ";"
  | ":"
  | "!"
  | 
    "?"
  | "="
  | "#"
  | "%"
  | "<"
  | ">"
  | "$"
  | "("
  | ")"
  | 
    "["
  | "]"
  | "{"
  | "}"
  | "\\"
  | "@"
  | "&"
  | "^"
  | "|" >
| < string :
    "\""
    (
      " "
    | < letter >
    | < digit >
    | < otherchar >
    )*
    "\"" >
}

SPECIAL_TOKEN :
{
  < comment : "/*" (~[ ])* "*/" >
}

void Literal() :
{}
{
  < TRUTHVALUE >
| < number >
}

void Selector() throws YAPLException :
{}
{
  (
    < openingBrackets > Expr() < closingBrackets >
  | < dot > < ident >
  )
  (
    Selector()
  )?
}

void ArrayLen() throws YAPLException :
{
	Token t;
}
{
  < hash > t = < ident >
  {
    lookup(11, null, t);
  }
  (
    Selector()
  )?
}

void PrimaryExpr() throws YAPLException :
{
	Token t;
}
{
  Literal()
| < openingParenthesis > Expr() < closingParenthesis >
|
  (
    LOOKAHEAD( t = < ident >, { getToken(2).kind == openingParenthesis })
    ProcedureCall()
  | t = < ident >
  {
    lookup(11, null, t);
  }
    (
      Selector()
    )?
  )
| ArrayLen()
}

void UnaryExpr() throws YAPLException :
{}
{
  (
    AddOp()
  )?
  PrimaryExpr()
}

void MulExpr() throws YAPLException :
{}
{
  UnaryExpr()
  (
    MulOp() UnaryExpr()
  )*
}

void AddExpr() throws YAPLException :
{}
{
  MulExpr()
  (
    AddOp() MulExpr()
  )*
}

void RelExpr() throws YAPLException :
{}
{
  AddExpr()
  (
    RelOp() AddExpr()
  )?
}

void EqualExpr() throws YAPLException :
{}
{
  RelExpr()
  (
    EqualOp() RelExpr()
  )?
}

void CondAndExpr() throws YAPLException :
{}
{
  EqualExpr()
  (
    < ANDOP > EqualExpr()
  )*
}

void CreationExpr()  throws YAPLException :
{}
{
  < NEWOP > NonArrayType()
  (
    < openingBrackets > Expr() < closingBrackets >
  )*
}

void Expr() throws YAPLException :
{}
{
  CondAndExpr()
  (
    < OROP > CondAndExpr()
  )*
| CreationExpr()
}

void ArgumentList() throws YAPLException :
{}
{
  Expr()
  (
    < colon > Expr()
  )*
}

void ProcedureCall() throws YAPLException :
{
	Token t;
}
{
  t = < ident > < openingParenthesis >
  {
	SymbolImpl sym = lookup(11, null, t);
	if(sym.getKind() != 1) {
		throw new YAPLException(12, sym, t);
	}  
  }  
  (
    ArgumentList()
  )?
  < closingParenthesis >
}

void Assignment() throws YAPLException:
{
  Token t;
}
{
  t = < ident >
  {
    lookup(11, null, t);
  }
  (
    Selector()
  )?
  < assignOp > Expr()
}

void IfStatement() throws YAPLException :
{}
{
  < IF > Expr() < THEN > StatementList()
  (
    < ELSE > StatementList()
  )?
  < ENDIF >
}

void WhileStatement() throws YAPLException :
{}
{
  < WHILE > Expr() < DO > StatementList() < ENDWHILE >
}

void ReturnStatement() throws YAPLException :
{}
{
  < RETURN >
  (
    Expr()
  )?
}

void WriteStatement() :
{}
{
  < WRITE > < string >
}

void Statement() throws YAPLException :
{
}
{
  IfStatement()
| WhileStatement()
| ReturnStatement()
| WriteStatement()
|
  (
    LOOKAHEAD(< ident >, { getToken(2).kind != openingParenthesis })
    Assignment()
  | ProcedureCall()
  )
| Block()
}

void StatementList() throws YAPLException :
{}
{
  (
    Statement() < DELIMITER >
  )*
}

void Block() throws YAPLException :
{}
{
  (
    Decl()
  )?
  < BEGIN >
  {
	table.openScope(false);
  }
  StatementList() < END >
  {
    table.closeScope();
  }
}

void NonArrayType() throws YAPLException :
{
	Token t;
}
{
  < INT >
| < BOOL >
| t = < ident >
{
  lookup(11, null, t);
}
}

void Type() throws YAPLException :
{}
{
  NonArrayType() (< openingBrackets > < closingBrackets >)*
}

void ReturnType() throws YAPLException :
{}
{
  < VOID >
| Type()
}

void ConstDecl() throws YAPLException :
{
	Token t;
}
{
  < CONSTANT > t = < ident > < constAssignOp > Literal() < DELIMITER >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(3);
    table.addSymbol(sym, t);
    table.setParentSymbol(sym);
  }
}

void VarDecl()  throws YAPLException:
{
	Token t;
	Token t2;
}
{
  {
	t2 = null;
  } 
  Type() t = < ident > ("," t2 = < ident >)* < DELIMITER >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(2);
    table.addSymbol(sym, t);
    if(t2 != null) {
      	SymbolImpl sym2 = new SymbolImpl();
    	sym2.setName(t2.toString());
    	sym2.setKind(2);
    	table.addSymbol(sym2, t2);
  	} 	
  }
}

void TypeDecl()  throws YAPLException:
{
	Token t;
}
{
  < RECORD > t = < ident > VarDecl()
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(4);
    table.addSymbol(sym, t);
    table.setParentSymbol(sym);
  }
  (
    VarDecl()
  )*
  < ENDRECORD > < DELIMITER >
}

void Decl()  throws YAPLException:
{}
{
  < DECLARE >
  (
    ConstDecl()
  | VarDecl()
  | TypeDecl()
  )*
}

void FormalParam() throws YAPLException :
{
	Token t;
}
{
  Type() t = < ident >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(6);
    table.addSymbol(sym, t);
    table.setParentSymbol(sym);
  }
}

void FormalParamList()  throws YAPLException :
{}
{
  FormalParam()
  (
    < colon > FormalParam()
  )*
}

void Procedure() throws YAPLException :
{
	Token t;
}
{
  < PROCEDURE > ReturnType() t = < ident > < openingParenthesis >
  {
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(1);
    table.addSymbol(sym, t);
    table.setParentSymbol(sym);
    table.openScope(false);
  }
  (
    FormalParamList()
  )?
  < closingParenthesis > Block() t = < ident > < DELIMITER >
  {
    lookup(13, sym, t);
    table.closeScope();
  }
}

void Program() throws YAPLException:
{
  Token t;
}
{
  < PROGRAM > t = < ident >
  {
    Parser.programName = t.toString();
    
    table.openScope(true);
    SymbolImpl sym = new SymbolImpl();
    sym.setName(t.toString());
    sym.setKind(0);
    table.addSymbol(sym, t);
    table.setParentSymbol(sym);
  }
  (
    Decl()
  | Procedure()
  )*
  < BEGIN > StatementList() < END > t = < ident > < dot >
  {
	lookup(13, sym, t);
	table.closeScope();
  }
}

void RelOp() :
{}
{
  < less >
| < lessequal >
| < greaterequal >
| < greater >
}

void EqualOp() :
{}
{
  < equals >
| < nequals >
}

void AddOp() :
{}
{
  < plus >
| < minus >
}

void MulOp() :
{}
{
  < multiply >
| < divide >
| < modulo >
}
